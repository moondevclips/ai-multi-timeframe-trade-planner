# To run this server:
# 1. Make sure you have Python installed.
# 2. Install the necessary libraries:
#    pip install Flask flask-cors requests google-generativeai gunicorn numpy
# 3. Save this code as a file (e.g., server.py).
# 4. Set up your API keys as environment variables on your hosting platform.
# 5. In your terminal, run the server: python server.py

import os
import requests
import google.generativeai as genai
from flask import Flask, request, jsonify
from flask_cors import CORS
from datetime import datetime, timedelta
import json
import logging
import numpy as np # NEW: Import numpy for calculations

# --- Configuration ---
# Set up your API keys as Environment Variables in your hosting provider's dashboard.
GOOGLE_API_KEY = os.environ.get("GOOGLE_API_KEY", "PASTE_YOUR_GEMINI_API_KEY_HERE")
POLYGON_API_KEY = os.environ.get("POLYGON_API_KEY", "PASTE_YOUR_POLYGON_API_KEY_HERE")
NEWS_API_KEY = os.environ.get("NEWS_API_KEY", "PASTE_YOUR_NEWSAPI_API_KEY_HERE")
FMP_API_KEY = os.environ.get("FMP_API_KEY", "PASTE_YOUR_FMP_API_KEY_HERE")
ALPHA_VANTAGE_API_KEY = os.environ.get("ALPHA_VANTAGE_API_KEY", "PASTE_YOUR_ALPHA_VANTAGE_API_KEY_HERE")

# --- Flask App Setup ---
app = Flask(__name__)
CORS(app, resources={r"/*": {"origins": "*"}})

# --- Logging Configuration ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Configure the Gemini API ---
model = None
if GOOGLE_API_KEY and GOOGLE_API_KEY != "PASTE_YOUR_GEMINI_API_KEY_HERE":
    try:
        genai.configure(api_key=GOOGLE_API_KEY)
        model = genai.GenerativeModel('gemini-1.5-flash')
        app.logger.info("Gemini API configured successfully.")
    except Exception as e:
        app.logger.error(f"Error configuring Gemini API: {e}")
else:
    app.logger.warning("Gemini API key is not configured.")

# --- API Helper Functions ---

def make_api_request(url, service_name):
    """Generic function to make a request and handle errors."""
    try:
        response = requests.get(url)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException as e:
        app.logger.error(f"Error fetching data from {service_name}: {e}")
        return None

def get_market_data(symbol, asset_class):
    if not POLYGON_API_KEY or POLYGON_API_KEY == "PASTE_YOUR_POLYGON_API_KEY_HERE": return None
    if asset_class.lower() == 'crypto':
        symbol = f"X:{symbol.upper()}"
    end_date = datetime.now()
    start_date = end_date - timedelta(days=5*365)
    url = f"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/1/day/{start_date.strftime('%Y-%m-%d')}/{end_date.strftime('%Y-%m-%d')}?adjusted=true&sort=asc&limit=5000&apiKey={POLYGON_API_KEY}"
    return make_api_request(url, "Polygon.io Market Data")

def calculate_sharpe_ratio(price_data, risk_free_rate=0.02):
    """Calculates the annualized Sharpe Ratio from daily price data."""
    if not price_data or len(price_data) < 2:
        return "N/A"
    
    prices = [item['c'] for item in price_data]
    daily_returns = (np.array(prices[1:]) - np.array(prices[:-1])) / np.array(prices[:-1])
    
    if np.std(daily_returns) == 0:
        return "N/A" # Avoid division by zero if there's no volatility

    excess_returns = daily_returns - (risk_free_rate / 252)
    sharpe_ratio = np.mean(excess_returns) / np.std(excess_returns)
    annualized_sharpe = sharpe_ratio * np.sqrt(252)
    
    return round(annualized_sharpe, 2)


def get_alpha_vantage_data(function, symbol, interval='daily'):
    if not ALPHA_VANTAGE_API_KEY or ALPHA_VANTAGE_API_KEY == "PASTE_YOUR_ALPHA_VANTAGE_API_KEY_HERE": return None
    base_url = f"https://www.alphavantage.co/query?function={function}&symbol={symbol}&apikey={ALPHA_VANTAGE_API_KEY}"
    if function in ["RSI", "EMA", "SMA"]:
        url = f"{base_url}&interval={interval}&time_period=14&series_type=close"
    elif function == "VWAP":
        url = f"{base_url}&interval={interval}"
    else:
        url = base_url
    return make_api_request(url, f"Alpha Vantage {function}")

def get_news_data(symbol):
    if not NEWS_API_KEY or NEWS_API_KEY == "PASTE_YOUR_NEWSAPI_API_KEY_HERE": return None
    url = f"https://newsapi.org/v2/everything?q={symbol}&sortBy=relevancy&pageSize=20&apiKey={NEWS_API_KEY}"
    return make_api_request(url, "NewsAPI")

# --- Endpoints ---
@app.route('/', methods=['GET'])
def health_check():
    return jsonify({"status": "ok", "message": "Backend server is running."}), 200

@app.route('/analyze-symbol', methods=['POST'])
def analyze_symbol():
    if not model: return jsonify({"error": "Gemini AI model is not configured."}), 503
    data = request.get_json()
    symbol, asset_class = data.get('symbol'), data.get('asset_class', 'stock')
    if not symbol: return jsonify({"error": "Symbol is required."}), 400

    app.logger.info(f"Starting analysis for symbol: {symbol}, asset class: {asset_class}")
    market_data = get_market_data(symbol, asset_class)
    news_data = get_news_data(symbol)
    
    av_symbol = symbol.split('-')[0]
    rsi_data = get_alpha_vantage_data("RSI", av_symbol)
    ema_data = get_alpha_vantage_data("EMA", av_symbol)
    sma_data = get_alpha_vantage_data("SMA", av_symbol)
    macd_data = get_alpha_vantage_data("MACD", av_symbol)
    vwap_data = get_alpha_vantage_data("VWAP", av_symbol, interval='60min')

    if not market_data or not news_data:
        return jsonify({"error": "Failed to fetch essential market or news data."}), 500

    # Calculate Sharpe Ratio
    sharpe_ratio = calculate_sharpe_ratio(market_data.get('results', [])[-90:]) # Use last 90 days

    technicals_summary = {
        "rsi": rsi_data.get("Technical Analysis: RSI", {}).get(next(iter(rsi_data.get("Technical Analysis: RSI", {})), None), {}).get("RSI") if rsi_data else "N/A",
        "ema": ema_data.get("Technical Analysis: EMA", {}).get(next(iter(ema_data.get("Technical Analysis: EMA", {})), None), {}).get("EMA") if ema_data else "N/A",
        "sma": sma_data.get("Technical Analysis: SMA", {}).get(next(iter(sma_data.get("Technical Analysis: SMA", {})), None), {}).get("SMA") if sma_data else "N/A",
        "macd": macd_data.get("Technical Analysis: MACD", {}).get(next(iter(macd_data.get("Technical Analysis: MACD", {})), None), {}) if macd_data else "N/A",
        "vwap": vwap_data.get("Technical Analysis: VWAP", {}).get(next(iter(vwap_data.get("Technical Analysis: VWAP", {})), None), {}).get("VWAP") if vwap_data else "N/A",
        "sharpeRatio": sharpe_ratio
    }
    
    prompt = f"""
    You are an expert institutional-level financial analyst. Your task is to perform a deep, multi-layered analysis of the provided data for the symbol {symbol} to formulate a high-quality swing trade setup.

    **1. Quantitative Technical Data:**
    {str(technicals_summary)}

    **2. Market Data (OHLCV for last year):**
    {str(market_data.get('results', [])[-365:])}

    **3. Recent News Headlines:**
    {[article.get('title', '') for article in news_data.get('articles', [])]}

    **Your Analysis Process:**
    1.  **Risk/Reward Profile:** This is crucial. Based on the quantitative technical data, provide a summary of the risk-to-reward profile. Explain how each metric (RSI, EMA, SMA, MACD, VWAP, Sharpe Ratio) contributes to this assessment. For example, 'A high Sharpe Ratio suggests good risk-adjusted returns, which supports a bullish thesis.'
    2.  **News Sentiment Analysis:** Determine the current market sentiment from the headlines.
    3.  **Price Action Analysis (3-Level Framework):** Analyze the OHLCV data to identify the current market structure (Retail, Stop-Hunt, Institutional zones).
    4.  **Historical Analogue Analysis:** Search the historical data for similar patterns and their outcomes.
    5.  **Final Verdict:** Synthesize ALL data points to provide a "YAY" or "NAY" verdict and a concise reason.

    **Goal:** Create a complete swing trade plan designed to reach its take profit target within the 4-hour mark of the trading day.

    **Output Format:**
    Return a single, minified JSON object with NO markdown formatting, following this exact structure:
    {{
      "tradePlan": {{ "entry": "...", "exit": "...", "stopLoss": "..." }},
      "verdict": {{ "recommendation": "YAY/NAY", "reason": "..." }},
      "quantitativeTechnicals": {json.dumps(technicals_summary)},
      "riskRewardProfile": "Your detailed explanation of how the metrics influence the risk/reward.",
      "sentiment": {{ "rating": "...", "summary": "..." }},
      "confidence": {{ "probability": "...", "assessment": "..." }},
      "historicalAnalogue": {{ "summary": "..." }},
      "analysis": {{ "summary": "...", "patterns": ["..."], "indicators": "..." }},
      "executionStrategy": "...",
      "relatedNews": ["..."]
    }}
    """
    return _get_gemini_response(prompt)

def _get_gemini_response(prompt, text_only=False):
    """Helper function to call Gemini and handle responses."""
    try:
        app.logger.info("Sending prompt to Gemini API...")
        response = model.generate_content(prompt)
        raw_text = response.text
        if text_only: return jsonify({"text": raw_text}), 200
        app.logger.info("Received response from Gemini. Attempting to parse JSON.")
        if raw_text.strip().startswith("```json"): raw_text = raw_text.strip()[7:-3]
        json_data = json.loads(raw_text)
        return jsonify(json_data), 200
    except Exception as e:
        app.logger.error(f"Error during Gemini analysis: {e}")
        return jsonify({"error": "Failed to get analysis from AI model."}), 500

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=5000, debug=True)
